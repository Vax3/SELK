import "core-js/modules/es7.symbol.async-iterator";
import "core-js/modules/es6.symbol";
import "core-js/modules/es6.object.set-prototype-of";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import React from 'react';
import PropTypes from 'prop-types';
import { AbstractSeries, ScaleUtils } from 'react-vis';
import { EuiSeriesChartUtils } from './utils/chart_utils';
import { EuiSeriesChartAxisUtils } from './utils/axis_utils';
var _EuiSeriesChartUtils$ = EuiSeriesChartUtils.ORIENTATION,
    HORIZONTAL = _EuiSeriesChartUtils$.HORIZONTAL,
    VERTICAL = _EuiSeriesChartUtils$.VERTICAL;
var _EuiSeriesChartAxisUt = EuiSeriesChartAxisUtils.TITLE_POSITION,
    START = _EuiSeriesChartAxisUt.START,
    MIDDLE = _EuiSeriesChartAxisUt.MIDDLE,
    END = _EuiSeriesChartAxisUt.END;
/**
 * Draw simple line annotation into the chart. Currently it's a work in progress
 * but will be extented to add text and tooltips if required.
 * The basic usage is for displaying the current time marker.
 */

export var EuiLineAnnotation =
/*#__PURE__*/
function (_AbstractSeries) {
  _inherits(EuiLineAnnotation, _AbstractSeries);

  function EuiLineAnnotation() {
    _classCallCheck(this, EuiLineAnnotation);

    return _possibleConstructorReturn(this, _getPrototypeOf(EuiLineAnnotation).apply(this, arguments));
  }

  _createClass(EuiLineAnnotation, [{
    key: "_getAttributeFunctor",

    /**
     * Get attribute functor.
     * @param {string} attr Attribute name
     * @returns {*} Functor.
     * @protected
     */
    value: function _getAttributeFunctor(attr) {
      return ScaleUtils.getAttributeFunctor(this.props, attr);
    }
    /**
     * Get the attribute value if it is available.
     * @param {string} attr Attribute name.
     * @returns {*} Attribute value if available, fallback value or undefined
     * otherwise.
     * @protected
     */

  }, {
    key: "_getAttributeValue",
    value: function _getAttributeValue(attr) {
      return ScaleUtils.getAttributeValue(this.props, attr);
    }
  }, {
    key: "_getTextXY",
    value: function _getTextXY(textPosition, min, max) {
      switch (textPosition) {
        case END:
          return min;

        case START:
          return max;

        case MIDDLE:
          return Math.abs((max - min) / 2);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          data = _this$props.data,
          orientation = _this$props.orientation,
          textPosition = _this$props.textPosition,
          innerHeight = _this$props.innerHeight,
          innerWidth = _this$props.innerWidth,
          marginLeft = _this$props.marginLeft,
          marginTop = _this$props.marginTop;
      var axis = orientation === HORIZONTAL ? 'y' : 'x';

      var scale = this._getAttributeFunctor(axis);

      return React.createElement("g", {
        className: "euiLineAnnotations",
        transform: "translate(".concat(marginLeft, ",").concat(marginTop, ")")
      }, React.createElement("g", {
        className: "euiLineAnnotations__linesGroup"
      }, data.map(function (d, i) {
        var value = d.value;
        var position = scale(_defineProperty({}, axis, value));
        return React.createElement("line", {
          key: "annotation-".concat(i),
          className: "euiLineAnnotations__line",
          x1: orientation === VERTICAL ? position : 0,
          y1: orientation === VERTICAL ? 0 : position,
          x2: orientation === VERTICAL ? position : innerWidth,
          y2: orientation === VERTICAL ? innerHeight : position
        });
      })), React.createElement("g", {
        className: "euiLineAnnotations__textGroup"
      }, data.filter(function (d) {
        return d.text;
      }).map(function (d, i) {
        var value = d.value;
        var x = 0;
        var y = 0;
        var rotation = 0;

        if (orientation === VERTICAL) {
          x = scale(_defineProperty({}, axis, value));
          y = _this._getTextXY(textPosition, 0, innerHeight);
          rotation = '-90';
        } else {
          x = _this._getTextXY(textPosition, innerWidth, 0);
          y = scale(_defineProperty({}, axis, value));
        }

        return React.createElement("text", {
          key: "annotation-".concat(i),
          className: "euiLineAnnotations__text",
          x: 0,
          y: 0,
          textAnchor: textPosition,
          transform: "translate(".concat(x, ",").concat(y, ") rotate(").concat(rotation, ")")
        }, d.text);
      })));
    }
  }]);

  return EuiLineAnnotation;
}(AbstractSeries);
EuiLineAnnotation.displayName = 'EuiLineAnnotation';
EuiLineAnnotation.propTypes = {
  /** An annotation data Array<{value: string|number, text: string}> */
  data: PropTypes.arrayOf(PropTypes.shape({
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    text: PropTypes.string
  })).isRequired,

  /** The orientation of the annotation. */
  orientation: PropTypes.oneOf([HORIZONTAL, VERTICAL]),
  textPosition: PropTypes.oneOf([START, MIDDLE, END])
};
EuiLineAnnotation.defaultProps = {
  orientation: VERTICAL,
  textPosition: START
};
EuiLineAnnotation.__docgenInfo = {
  "description": "Draw simple line annotation into the chart. Currently it's a work in progress\nbut will be extented to add text and tooltips if required.\nThe basic usage is for displaying the current time marker.",
  "methods": [{
    "name": "_getAttributeFunctor",
    "docblock": "Get attribute functor.\n@param {string} attr Attribute name\n@returns {*} Functor.\n@protected",
    "modifiers": [],
    "params": [{
      "name": "attr",
      "description": "Attribute name",
      "type": {
        "name": "string"
      },
      "optional": false
    }],
    "returns": {
      "description": "Functor.",
      "type": {
        "name": "mixed"
      }
    },
    "description": "Get attribute functor."
  }, {
    "name": "_getAttributeValue",
    "docblock": "Get the attribute value if it is available.\n@param {string} attr Attribute name.\n@returns {*} Attribute value if available, fallback value or undefined\notherwise.\n@protected",
    "modifiers": [],
    "params": [{
      "name": "attr",
      "description": "Attribute name.",
      "type": {
        "name": "string"
      },
      "optional": false
    }],
    "returns": {
      "description": "Attribute value if available, fallback value or undefined\notherwise.",
      "type": {
        "name": "mixed"
      }
    },
    "description": "Get the attribute value if it is available."
  }, {
    "name": "_getTextXY",
    "docblock": null,
    "modifiers": [],
    "params": [{
      "name": "textPosition",
      "type": null
    }, {
      "name": "min",
      "type": null
    }, {
      "name": "max",
      "type": null
    }],
    "returns": null
  }],
  "displayName": "EuiLineAnnotation",
  "props": {
    "orientation": {
      "defaultValue": {
        "value": "EuiSeriesChartUtils.ORIENTATION.VERTICAL",
        "computed": true
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "EuiSeriesChartUtils.ORIENTATION.HORIZONTAL",
          "computed": true
        }, {
          "value": "EuiSeriesChartUtils.ORIENTATION.VERTICAL",
          "computed": true
        }]
      },
      "required": false,
      "description": "The orientation of the annotation."
    },
    "textPosition": {
      "defaultValue": {
        "value": "EuiSeriesChartAxisUtils.TITLE_POSITION.START",
        "computed": true
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "EuiSeriesChartAxisUtils.TITLE_POSITION.START",
          "computed": true
        }, {
          "value": "EuiSeriesChartAxisUtils.TITLE_POSITION.MIDDLE",
          "computed": true
        }, {
          "value": "EuiSeriesChartAxisUtils.TITLE_POSITION.END",
          "computed": true
        }]
      },
      "required": false,
      "description": ""
    },
    "data": {
      "type": {
        "name": "arrayOf",
        "value": {
          "name": "shape",
          "value": {
            "value": {
              "name": "union",
              "value": [{
                "name": "string"
              }, {
                "name": "number"
              }],
              "required": false
            },
            "text": {
              "name": "string",
              "required": false
            }
          }
        }
      },
      "required": true,
      "description": "An annotation data Array<{value: string|number, text: string}>"
    }
  }
};