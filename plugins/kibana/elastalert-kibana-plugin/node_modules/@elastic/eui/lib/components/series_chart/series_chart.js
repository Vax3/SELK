"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EuiSeriesChart = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.object.assign");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/es6.function.name");

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactVis = require("react-vis");

var _flexible = require("./utils/flexible");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _empty_prompt = require("../empty_prompt");

var _selection_brush = require("./selection_brush");

var _default_axis = require("./axis/default_axis");

var _crosshair_x = require("./crosshairs/crosshair_x");

var _crosshair_y = require("./crosshairs/crosshair_y");

var _services = require("../../services");

var _chart_utils = require("./utils/chart_utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HORIZONTAL = _chart_utils.ORIENTATION.HORIZONTAL,
    VERTICAL = _chart_utils.ORIENTATION.VERTICAL,
    BOTH = _chart_utils.ORIENTATION.BOTH;
var LINEAR = _chart_utils.SCALE.LINEAR,
    ORDINAL = _chart_utils.SCALE.ORDINAL,
    CATEGORY = _chart_utils.SCALE.CATEGORY,
    TIME = _chart_utils.SCALE.TIME,
    TIME_UTC = _chart_utils.SCALE.TIME_UTC,
    LOG = _chart_utils.SCALE.LOG,
    LITERAL = _chart_utils.SCALE.LITERAL;
var DEFAULT_MARGINS = {
  left: 40,
  right: 10,
  top: 10,
  bottom: 40
};
/**
 * The root component of any XY chart.
 * It renders an react-vis XYPlot including default axis and a valid crosshair.
 * You can also enable the Selection Brush.
 */

var XYChart =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(XYChart, _PureComponent);

  function XYChart() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, XYChart);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(XYChart)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      mouseOver: false
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "colorIterator", 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_xyPlotRef", _react.default.createRef());

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getSeriesNames", function (children) {
      return _react.default.Children.toArray(children).filter(_this._isAbstractSeries).map(function (_ref) {
        var name = _ref.props.name;
        return name;
      });
    });

    return _this;
  }

  _createClass(XYChart, [{
    key: "_isEmptyPlot",

    /**
     * Checks if the plot is empty, looking at existing series and data props.
     */
    value: function _isEmptyPlot(children) {
      return _react.default.Children.toArray(children).filter(this._isAbstractSeries).filter(function (child) {
        return child.props.data && child.props.data.length > 0;
      }).length === 0;
    }
    /**
     * Checks if a react child is an AbstractSeries
     */

  }, {
    key: "_isAbstractSeries",
    value: function _isAbstractSeries(child) {
      var prototype = child.type.prototype; // Avoid applying chart props to non series children

      return prototype instanceof _reactVis.AbstractSeries;
    }
    /**
     * Render children adding a valid EUI visualization color if the color prop is not specified.
     */

  }, {
    key: "_renderChildren",
    value: function _renderChildren(children) {
      var _this2 = this;

      var colorIterator = 0;
      return _react.default.Children.map(children, function (child, i) {
        // Avoid applying color props to non series children
        if (!_this2._isAbstractSeries(child)) {
          return child;
        }

        var props = {
          id: "chart-".concat(i)
        };

        if (!child.props.color) {
          props.color = _services.VISUALIZATION_COLORS[colorIterator % _services.VISUALIZATION_COLORS.length];
          colorIterator++;
        }

        props._orientation = _this2.props.orientation;
        return _react.default.cloneElement(child, props);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          width = _this$props.width,
          height = _this$props.height,
          margins = _this$props.margins,
          xType = _this$props.xType,
          xCrosshairFormat = _this$props.xCrosshairFormat,
          yCrosshairFormat = _this$props.yCrosshairFormat,
          yType = _this$props.yType,
          stackBy = _this$props.stackBy,
          statusText = _this$props.statusText,
          xDomain = _this$props.xDomain,
          yDomain = _this$props.yDomain,
          yPadding = _this$props.yPadding,
          xPadding = _this$props.xPadding,
          animateData = _this$props.animateData,
          showDefaultAxis = _this$props.showDefaultAxis,
          showCrosshair = _this$props.showCrosshair,
          enableSelectionBrush = _this$props.enableSelectionBrush,
          selectionBrushOrientation = _this$props.selectionBrushOrientation,
          onSelectionBrushEnd = _this$props.onSelectionBrushEnd,
          orientation = _this$props.orientation,
          crosshairValue = _this$props.crosshairValue,
          onCrosshairUpdate = _this$props.onCrosshairUpdate,
          className = _this$props.className,
          rest = _objectWithoutProperties(_this$props, ["children", "width", "height", "margins", "xType", "xCrosshairFormat", "yCrosshairFormat", "yType", "stackBy", "statusText", "xDomain", "yDomain", "yPadding", "xPadding", "animateData", "showDefaultAxis", "showCrosshair", "enableSelectionBrush", "selectionBrushOrientation", "onSelectionBrushEnd", "orientation", "crosshairValue", "onCrosshairUpdate", "className"]);

      if (this._isEmptyPlot(children)) {
        return _react.default.createElement(_empty_prompt.EuiEmptyPrompt, {
          className: "euiSeriesChartContainer__emptyPrompt",
          iconType: "visualizeApp",
          title: _react.default.createElement("span", null, "Chart not available"),
          body: _react.default.createElement("p", null, statusText)
        });
      }

      var Crosshair = orientation === HORIZONTAL ? _crosshair_y.EuiCrosshairY : _crosshair_x.EuiCrosshairX;

      var seriesNames = this._getSeriesNames(children);

      var classes = (0, _classnames.default)(className, 'euiSeriesChartContainer');
      return _react.default.createElement("div", _extends({
        className: classes
      }, rest), _react.default.createElement(_reactVis.XYPlot, {
        ref: this._xyPlotRef,
        dontCheckIfEmpty: true,
        width: width,
        animation: animateData,
        height: height,
        margin: margins,
        xType: xType,
        yType: yType,
        xDomain: xDomain,
        yDomain: yDomain,
        stackBy: stackBy,
        yPadding: yPadding,
        xPadding: xPadding,
        style: {
          width: '100%',
          height: '100%'
        }
      }, this._renderChildren(children), showDefaultAxis && _react.default.createElement(_default_axis.EuiDefaultAxis, {
        orientation: orientation
      }), showCrosshair && _react.default.createElement(Crosshair, {
        seriesNames: seriesNames,
        crosshairValue: crosshairValue,
        onCrosshairUpdate: onCrosshairUpdate,
        xCrosshairFormat: xCrosshairFormat,
        yCrosshairFormat: yCrosshairFormat
      }), enableSelectionBrush && _react.default.createElement(_selection_brush.EuiSelectionBrush, {
        onBrushEnd: onSelectionBrushEnd,
        orientation: selectionBrushOrientation
      })));
    }
  }]);

  return XYChart;
}(_react.PureComponent);

XYChart.displayName = 'EuiSeriesChart';
XYChart.propTypes = {
  /** The initial width of the chart. */
  width: _propTypes.default.number.isRequired,

  /** The initial height of the chart. */
  height: _propTypes.default.number.isRequired,

  /** **experimental** The orientation of the chart. */
  orientation: _propTypes.default.oneOf([HORIZONTAL, VERTICAL]),

  /** If the chart animates on data changes. */
  animateData: _propTypes.default.bool,

  /** TODO */
  stackBy: _propTypes.default.string,

  /** The main x axis scale type. See https://github.com/uber/react-vis/blob/master/docs/scales-and-data.md */
  xType: _propTypes.default.oneOf([LINEAR, ORDINAL, CATEGORY, TIME, TIME_UTC, LOG, LITERAL]),

  /** The formatting string for the X-axis. */
  xCrosshairFormat: _propTypes.default.string,

  /** The formatting string for the Y-axis. */
  yCrosshairFormat: _propTypes.default.string,

  /** The main y axis scale type. See https://github.com/uber/react-vis/blob/master/docs/scales-and-data.md*/
  yType: _propTypes.default.oneOf([LINEAR, ORDINAL, CATEGORY, TIME, TIME_UTC, LOG, LITERAL]),

  /** Manually specify the domain of x axis. */
  xDomain: _propTypes.default.array,

  /** Manually specify the domain of y axis. */
  yDomain: _propTypes.default.array,

  /** The horizontal padding between the chart borders and chart elements. */
  xPadding: _propTypes.default.number,

  /** The vertical padding between the chart borders and chart elements. */
  yPadding: _propTypes.default.number,

  /** Add an additional status text above the graph status message*/
  statusText: _propTypes.default.string,

  /** Shows the crosshair tooltip on mouse move.*/
  showCrosshair: _propTypes.default.bool,

  /** Specify the axis value where to display crosshair based on chart orientation value. */
  crosshairValue: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /** Callback when the crosshair position is updated. */
  onCrosshairUpdate: _propTypes.default.func,

  /** Show the default X and Y axis. */
  showDefaultAxis: _propTypes.default.bool,

  /** Enable the brush tool */
  enableSelectionBrush: _propTypes.default.bool,

  /** Specify the brush orientation */
  selectionBrushOrientation: _propTypes.default.oneOf([HORIZONTAL, VERTICAL, BOTH]),

  /** Callback on brush end event with { begin, end } object returned. */
  onSelectionBrushEnd: _propTypes.default.func
};
XYChart.defaultProps = {
  animateData: true,
  xType: 'linear',
  yType: 'linear',
  yPadding: 0,
  xPadding: 0,
  orientation: VERTICAL,
  showCrosshair: true,
  showDefaultAxis: true,
  enableSelectionBrush: false,
  selectionBrushOrientation: HORIZONTAL,
  margins: DEFAULT_MARGINS
};
var EuiSeriesChart = (0, _flexible.makeFlexible)(XYChart);
exports.EuiSeriesChart = EuiSeriesChart;
XYChart.__docgenInfo = {
  "description": "The root component of any XY chart.\nIt renders an react-vis XYPlot including default axis and a valid crosshair.\nYou can also enable the Selection Brush.",
  "methods": [{
    "name": "_isEmptyPlot",
    "docblock": "Checks if the plot is empty, looking at existing series and data props.",
    "modifiers": [],
    "params": [{
      "name": "children"
    }],
    "returns": null,
    "description": "Checks if the plot is empty, looking at existing series and data props."
  }, {
    "name": "_isAbstractSeries",
    "docblock": "Checks if a react child is an AbstractSeries",
    "modifiers": [],
    "params": [{
      "name": "child"
    }],
    "returns": null,
    "description": "Checks if a react child is an AbstractSeries"
  }, {
    "name": "_renderChildren",
    "docblock": "Render children adding a valid EUI visualization color if the color prop is not specified.",
    "modifiers": [],
    "params": [{
      "name": "children"
    }],
    "returns": null,
    "description": "Render children adding a valid EUI visualization color if the color prop is not specified."
  }, {
    "name": "_getSeriesNames",
    "docblock": null,
    "modifiers": [],
    "params": [{
      "name": "children",
      "type": null
    }],
    "returns": null
  }],
  "displayName": "EuiSeriesChart",
  "props": {
    "animateData": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "type": {
        "name": "bool"
      },
      "required": false,
      "description": "If the chart animates on data changes."
    },
    "xType": {
      "defaultValue": {
        "value": "'linear'",
        "computed": false
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "SCALE.LINEAR",
          "computed": true
        }, {
          "value": "SCALE.ORDINAL",
          "computed": true
        }, {
          "value": "SCALE.CATEGORY",
          "computed": true
        }, {
          "value": "SCALE.TIME",
          "computed": true
        }, {
          "value": "SCALE.TIME_UTC",
          "computed": true
        }, {
          "value": "SCALE.LOG",
          "computed": true
        }, {
          "value": "SCALE.LITERAL",
          "computed": true
        }]
      },
      "required": false,
      "description": "The main x axis scale type. See https://github.com/uber/react-vis/blob/master/docs/scales-and-data.md"
    },
    "yType": {
      "defaultValue": {
        "value": "'linear'",
        "computed": false
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "SCALE.LINEAR",
          "computed": true
        }, {
          "value": "SCALE.ORDINAL",
          "computed": true
        }, {
          "value": "SCALE.CATEGORY",
          "computed": true
        }, {
          "value": "SCALE.TIME",
          "computed": true
        }, {
          "value": "SCALE.TIME_UTC",
          "computed": true
        }, {
          "value": "SCALE.LOG",
          "computed": true
        }, {
          "value": "SCALE.LITERAL",
          "computed": true
        }]
      },
      "required": false,
      "description": "The main y axis scale type. See https://github.com/uber/react-vis/blob/master/docs/scales-and-data.md"
    },
    "yPadding": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "type": {
        "name": "number"
      },
      "required": false,
      "description": "The vertical padding between the chart borders and chart elements."
    },
    "xPadding": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "type": {
        "name": "number"
      },
      "required": false,
      "description": "The horizontal padding between the chart borders and chart elements."
    },
    "orientation": {
      "defaultValue": {
        "value": "ORIENTATION.VERTICAL",
        "computed": true
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "ORIENTATION.HORIZONTAL",
          "computed": true
        }, {
          "value": "ORIENTATION.VERTICAL",
          "computed": true
        }]
      },
      "required": false,
      "description": "**experimental** The orientation of the chart."
    },
    "showCrosshair": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "type": {
        "name": "bool"
      },
      "required": false,
      "description": "Shows the crosshair tooltip on mouse move."
    },
    "showDefaultAxis": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "type": {
        "name": "bool"
      },
      "required": false,
      "description": "Show the default X and Y axis."
    },
    "enableSelectionBrush": {
      "defaultValue": {
        "value": "false",
        "computed": false
      },
      "type": {
        "name": "bool"
      },
      "required": false,
      "description": "Enable the brush tool"
    },
    "selectionBrushOrientation": {
      "defaultValue": {
        "value": "ORIENTATION.HORIZONTAL",
        "computed": true
      },
      "type": {
        "name": "enum",
        "value": [{
          "value": "ORIENTATION.HORIZONTAL",
          "computed": true
        }, {
          "value": "ORIENTATION.VERTICAL",
          "computed": true
        }, {
          "value": "ORIENTATION.BOTH",
          "computed": true
        }]
      },
      "required": false,
      "description": "Specify the brush orientation"
    },
    "margins": {
      "defaultValue": {
        "value": "{\n  left: 40,\n  right: 10,\n  top: 10,\n  bottom: 40,\n}",
        "computed": false
      },
      "required": false
    },
    "width": {
      "type": {
        "name": "number"
      },
      "required": true,
      "description": "The initial width of the chart."
    },
    "height": {
      "type": {
        "name": "number"
      },
      "required": true,
      "description": "The initial height of the chart."
    },
    "stackBy": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "TODO"
    },
    "xCrosshairFormat": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "The formatting string for the X-axis."
    },
    "yCrosshairFormat": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "The formatting string for the Y-axis."
    },
    "xDomain": {
      "type": {
        "name": "array"
      },
      "required": false,
      "description": "Manually specify the domain of x axis."
    },
    "yDomain": {
      "type": {
        "name": "array"
      },
      "required": false,
      "description": "Manually specify the domain of y axis."
    },
    "statusText": {
      "type": {
        "name": "string"
      },
      "required": false,
      "description": "Add an additional status text above the graph status message"
    },
    "crosshairValue": {
      "type": {
        "name": "union",
        "value": [{
          "name": "string"
        }, {
          "name": "number"
        }]
      },
      "required": false,
      "description": "Specify the axis value where to display crosshair based on chart orientation value."
    },
    "onCrosshairUpdate": {
      "type": {
        "name": "func"
      },
      "required": false,
      "description": "Callback when the crosshair position is updated."
    },
    "onSelectionBrushEnd": {
      "type": {
        "name": "func"
      },
      "required": false,
      "description": "Callback on brush end event with { begin, end } object returned."
    }
  }
};